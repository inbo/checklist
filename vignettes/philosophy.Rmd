---
title: "Philosophy of the checklist package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Philosophy of the checklist package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Everybody develops its own coding habits and style.
Some people take a lot of effort in making their source code [readable](https://en.wikipedia.org/wiki/Computer_programming#Readability_of_source_code), while others don't bother at all.
Working together with different people is easier when everyone uses the same standard.
The `checklist` package defines a set of standards and provides tools to validate whether your project or R package adheres to these standards.
You can run these tools interactively on your machine.
You can also add these checks as [GitHub actions](https://github.com/features/actions), which runs them automatically after every [push](https://github.com/git-guides/git-push) to the repository on [GitHub](https://github.com).

## File name conventions

To make this easier to remember we choose the same name conventions for file names as for objects.
We acknowledge that these rules sometimes clash with requirements from other sources (e.g. `DESCRIPTION` in an R package, `README.md` on GitHub, `.gitignore` for git, ...).
In such case we allow the file names as required by R, git or GitHub.
When `check_filename()` does unfairly not allow a certain file or folder name, then please open an [issue on GitHub](https://github.com/inbo/checklist/issues) and motivate why this should be allowed.

### Rules for folder names

- Folder names should only contain lower case letters, numbers and underscore (`_`).
- They can start with a single dot (`.`).

### Rules for file names

- Base names should only contain lower case letters, numbers and underscore (`_`).
- File extensions should only contains lower case letters and numbers.
  Exceptions: file extensions related to R must have an upper case R (`.R`, `.Rmd`, `.Rd`, `.Rnw`, `.Rproj`).

### Rules for graphical file names

- Applies to files with extensions `csl`, `eps`, `jpg`, `jpeg`, `pdf`, `png` and `ps`.
- Same rules except that you need to use a dash (`-`) as separator instead of an underscore (`_`).
  We need this exception because underscores cause problems in certain situations.

## Bundling your code in a package

Most users think of an R package as a collection of generic functions that they can use to run their analysis.
However, an R package is a useful way to bundle and document a stand-alone analysis too!
Suppose you want to pass your code to a collaborator or your future self who is working on a different computer.
If you have a project folder with a bunch of files, people will need to get to know your project structure, find out what scripts to run and which dependencies they need.
Unless you documented everything well they (including your future self!) will have a hard time figuring out how things work.

Having the analysis as a package _and_ running `check_package()` to ensure a minimal quality standard, makes things a lot easier for the user.
Agreed, it will take a bit more time to create the analysis, especially with the first few projects.
In the long run you save time due to a better quality of your code.
Try to start by packaging a recurrent analysis or standardised report when you want to learn writing a package.
Once you have some experience, it is little overhead to do it for smaller analysis.
Keep in mind that you seldom run an analysis _exactly_ once.

### Benefits

- The package itself is a way to cite (a specific version of) the analysis in a report or paper.
- You have to list all dependencies on other R packages.
  This makes installing your code as simple as running `remotes::install_github("inbo/packagename")`.
- You must split your analysis in a set of functions.
  Say goodbye to scripts with thousands lines of code.
- Functions make it easy to re-use code.
  Need to run the same thing with a different parameter value?
  Add the parameter as an argument to the function and run the function once for every different parameter value.
  This avoids the need to copy-paste large chunks of scripts and replace a few values.
  The copy-paste work flow typically results in hard-to-read long scripts.
  Imagine you made a mistake in the code and copy-pasted that mistake several times before you found it.
  You have to check your entire project to fix the mistake several times.
  Having it as a function reduces the workload to fixing only the function.
- Packages require that every object is either defined within the package or imported from another package.
  Global variables are not allowed.
  The user only needs to load your package and run the function with the required arguments.
  The results will not depend on any other packages loaded nor by user-defined objects like vectors or dataframes (unless the user passes them explicitly as arguments to a function).
- A package gives the opportunity to add documentation to your code.
  Afterwards you can simply consult this documentation rather than having to dig into your code to find out what it is actually doing.
  Every function needs at least a title and an entry for every argument.
- Most likely you would still need a short script that combines a few high level functions of your package to run the analysis.
  The `inst` folder is an ideal place to bundle such scripts within the package.
  You can also use it to store small (!) datasets or rmarkdown reports.
